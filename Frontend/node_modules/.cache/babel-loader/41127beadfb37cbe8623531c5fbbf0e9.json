{"ast":null,"code":"function Diff() {}\n\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\n\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n} //\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n} // Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\n\n\nfunction distanceIterator(start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange; // If we have previous context, start with that\n\n\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2; // Overlapping\n\n\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3; // end the range and output\n\n\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines; // Mine inserted\n\n\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2; // Theirs inserted\n\n\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n} // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\n\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };","map":{"version":3,"names":["Diff","prototype","diff","oldString","newString","options","arguments","length","undefined","callback","self","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","Math","min","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path","characterDiff","diffChars","oldStr","newStr","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","diffWords","diffWordsWithSpace","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","trim","diffLines","diffTrimmedLines","sentenceDiff","diffSentences","cssDiff","diffCss","_typeof","obj","Symbol","iterator","constructor","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Object","from","o","minLen","n","toString","call","len","arr2","TypeError","objectPrototypeToString","jsonDiff","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","canonicalize","replace","diffJson","oldObj","newObj","stack","replacementStack","replacer","key","canonicalizedObj","toJSON","sortedKeys","_key","sort","arrayDiff","diffArrays","oldArr","newArr","parsePatch","uniDiff","diffstr","delimiters","match","list","parseIndex","index","header","parseFileHeader","hunks","_line","parseHunk","strict","Error","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","offset","removeEOFNL","addEOFNL","hunkFits","toPos","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","_curRange","prev","apply","_curRange2","_curRange3","contextSize","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","createTwoFilesPatch","createPatch","arrayEqual","a","b","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","merge","mine","theirs","base","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","Infinity","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","param","patch","conflict","check","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","state","matchChanges","changes","matchIndex","contextChanges","conflicted","change","reduce","removeChanges","delta","changeContent","forEach","myCount","theirCount","convertChangesToDMP","convertChangesToXML","escapeHTML","s"],"sources":["C:/Users/hecto/source/repos/React-Projects/covered/Covered/node_modules/diff/lib/index.mjs"],"sourcesContent":["function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n\n    if (options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n\n  if (!diff) {\n    return;\n  }\n\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}